import * as querystring from "querystring";

// TYPES_IMPORT

// TYPES_CLIENT

class SexpressClass {
  constructor(
    config: {
      baseURL?: string;
      getHeaders?: () => any;
      onError: (status: number, error: Error) => Promise<any>;
    } = {
      baseURL: '',
      getHeaders: () => ({}),
      onError: async () => null,
    },
  ) {
    this.baseURL = config.baseURL || "";
    this.headerFn = config.getHeaders;
    this.onError = config.onError;
  }

  getHeaders = () => {
    return { ...this.BASE_HEADERS, ...this.headerFn() };
  };

  BASE_HEADERS = {
    Accept: "application/json",
    "Content-Type": "application/json",
    "Cache-Control": "no-cache",
  };

  baseURL = "";
  headerFn: any = () => ({});
  onError: (status: number, error: Error) => Promise<any>;

  put = (url: string, data: any = {}) => {
    return this._fetch(this.baseURL + url, {
      method: "PUT",
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
  };

  post = (url: string, data: any = {}) => {
    return this._fetch(this.baseURL + url, {
      method: "POST",
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
  };

  patch = (url: string, data: any = {}) => {
    return this._fetch(this.baseURL + url, {
      method: "PATCH",
      headers: this.getHeaders(),
      body: JSON.stringify(data),
    });
  };

  get = (url: string, params: any = {}) => {
    const queryString = "?" + querystring.stringify(params);
    return this._fetch(this.baseURL + url + queryString, {
      method: "GET",
      headers: this.getHeaders(),
    });
  };

  delete = (url: string, params: any = {}) => {
    const queryString = "?" + querystring.stringify(params);
    return this._fetch(this.baseURL + url + queryString, {
      method: "DELETE",
      headers: this.getHeaders(),
    });
  };

  _fetch = async (url: string, options: any) => {
    const res = await fetch(url, options);

    if (res.status >= 400) {
      let jsonError: any;
      try {
        const errJson = await res.json();
        if (errJson.error) {
          jsonError = new Error(errJson.error);
        }
      } catch (e) {
        const err: any = e;
        jsonError = new Error(err);
      } finally {
        if (this.onError) {
          await this.onError(res.status, jsonError, async () =>
            this._fetch(url, options),
          );
        } else {
          // eslint-disable-next-line
          throw jsonError;
        }
      }
    } else {
      return res.json();
    }
  };

  FUNCTIONS;
}

export default SexpressClass;
